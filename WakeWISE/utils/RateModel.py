import os
from abc import ABC, abstractmethod
from pathlib import Path

import numpy as np

from WakeWISE.utils.time import TimeKeeper

base_path = Path(__file__).parent

class RateModel(ABC):

    def __init__(self, rates: np.ndarray) -> None:

        self.rates = np.array(rates)
        self.min = np.min(self.rates)
        self.max = np.max(self.rates)
        self.mean = np.mean(self.rates)
        self.std = np.std(self.rates)
        super().__init__()

    @abstractmethod
    def __call__(self, time: TimeKeeper) -> float:
        """
        Calculate the electricity price based on the time

        args:
            power (float): The power generated by the solar panel
            time: (TimeKeeper): The time of the day

        returns:
            float: The price per unit power rate
        """

    def run(self, time: TimeKeeper) -> float:
        """
        Calculate the electricity price based on the time
        
        args:
            time: (TimeKeeper): The time of the day
            
        returns:
            float: The price per unit power rate
        """

        return self(time)

    def __str__(self) -> str:
        return self.__class__.__name__
    

class SimpleRateModel(RateModel):

    def __init__(self, rate: float = 0.1) -> None:

        assert isinstance(rate, float), f"Error: rate must be a float, not {type(rate)}"
        assert rate >= 0, f"Error: rate must be greater than or equal to 0, not {rate}"

        super().__init__(rate)

    def __call__(self, time: TimeKeeper) -> float:
        return self.rates

    def __str__(self) -> str:
        return f"{super().__str__()}(price={self.rate})"
    
class HourlyRateModel(RateModel):

    def __init__(self, rates: list) -> None:

        assert isinstance(rates, list), f"Error: rates must be a list, not {type(rates)}"
        assert all([isinstance(x, float) for x in rates]), f"Error: rates must be a list of floats, not {rates}"
        assert all([x >= 0 for x in rates]), f"Error: rates must be a list of floats greater than or equal to 0, not {rates}"

        super().__init__(rates)

    def __call__(self, time: TimeKeeper) -> float:
        return self.rates[time.hours]

    def __str__(self) -> str:
        return f"{super().__str__()}(rates={self.rates})"
    
class MonthlyHourlyRateModel(RateModel):

    def __init__(self, rates: 'str | list' = None) -> None:

        if isinstance(rates, str):
            assert os.path.exists(rates), f"Error: File {rates} does not exist"
            rates = np.load(rates)
            assert rates.shape == (24, 12), f"Error: rates must be a 12x24 array, not {rates.shape}"
        elif isinstance(rates, list):
            assert all([isinstance(x, list) for x in rates]), f"Error: rates must be a list of lists, not {rates}"
            assert all([all([isinstance(y, float) for y in x]) for x in rates]), f"Error: rates must be a list of lists of floats, not {rates}"
            assert all([all([y >= 0 for y in x]) for x in rates]), f"Error: rates must be a list of lists of floats greater than or equal to 0, not {rates}"
            rates = np.array(rates)
            assert rates.shape == (24, 12), f"Error: rates must be a 12x24 array, not {rates.shape}"
        else:
            rates = np.load(f'{base_path}/../data/SpotPrices/NordPool_MM_HH_price_matrix_SYSTEM_WITH_NEG.npy')

        super().__init__(rates)

    def __call__(self, time: TimeKeeper) -> float:

        return self.rates[time.hours, time.months]
    
    def __str__(self) -> str:
        return f"{super().__str__()}(rates={self.rates.shape} array)"